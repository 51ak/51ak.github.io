<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>整理SQL*PLUS命令</title>
<link href="../../img/main.css" rel="stylesheet" type="text/css" />
<script src="../../img/daohang.js" type="text/javascript"></script>
<meta name="description" content="编辑整理sql*plus命令使用大全<br/>oracle的sql*plus是与oracle进行交互的客户端工具。在sql*plus中，可以运行sql*plus命令与sql*plus语句。&nbsp;&nbsp;&nbsp;我们通常所说的dml、ddl、dcl语句都是sql*plus语句，它们执行完后，都可以保存在一个被称为sqlbuffer的内存区域中，并且只能保存一条最近执行的sql语句整理SQL*PLUS命令" />

</head>

<body>

<div id="container">
  <div id="header">
<div class="dh-logo cls"> <div class="dh-logo-logo" ><a href="#"><img src="../../img/logo.gif" alt="数据库管理员DBA学习网站  LOGO"  width="251" height="58" /></a></div><div class="dh-logo-ac" id="topbar"><div class="dh-logo-nav">    <span class="f_black">Tips</span>： 亲爱的<span class="f_333" title="注：网站的访客">GUEST</span>用户，系统已为你<span class="f_333" title="注：不解释">GRANT</span>了<span class="f_333" title="注：可以查看网站上的所有文章">SELECT</span>,<a href="/add.aspx" title="注：可以发表文章" rel="nofollow">INSERT</a> 权限 </div> </div></div>
<div id="topMain"><div id="top"><ul class="nav"><li><a href="../../index.htm">网站首页</a></li><li><a  href="../sqlserver/l_1_1.htm" title="SQLServer">SQLServer</a></li><li><a href="../Oracle/l_7_1.htm" class="hover"　title="Oracle">Oracle</a></li><li><a  href="../mysql/l_13_1.htm" title="MySQL">MySQL</a></li><li><a  href="../othersql/l_19_1.htm" title="其他数据库">其他数据库</a></li><li><a  href="../yunwei/l_26_1.htm" title="系统运维">系统运维</a></li><li><a  href="../kaoshi/l_34_1.htm" title="DBA考试">DBA考试</a></li><li><a  href="../dbahuati/l_39_1.htm" title="DBA话题">DBA话题</a></li></ul><ul class="sub"><li><a  href="../Oraclezhishi/l_8_1.htm" title="Oracle基础知识"><span class="zc_666">基础知识</span></a>|</li><li><a  href="../Oracleha/l_9_1.htm" title="Oracle高可用性和HA">高可用性和HA</a>|</li><li><a  href="../Oracleyouhua/l_10_1.htm" title="Oracle性能与优化">性能与优化</a>|</li><li><a  href="../Oracleguzhang/l_11_1.htm" title="Oracle故障与解决">故障与解决</a>|</li><li><a  href="../Oraclebi/l_12_1.htm" title="Oracle商业应用">Oracle商业应用</a>|</li></ul></div></div>
<br class="clearfloat" />

  </div>
    <div class="local_daohang">您现在的位置: <a href="../../">首页</a> &nbsp;&gt;&nbsp;<a href="../Oracle/l_7_1.htm">Oracle</a>&nbsp;&gt;&nbsp;<a href="../Oraclezhishi/l_8_1.htm">基础知识</a></div>
  <div id="sidebar1">

  
  <div class='div_tab_tab'>
	<div id="div_login_title">通行证登录</div>
          <div id="div_login"> <iframe src="../../page/login.html" frameBorder="0" width="100%"  scrolling="no" height="190"></iframe>  
              &nbsp;</div>     
  </div>
    
  
   <div  class='div_tab_tab'>
  <div id="div_ran" > <span>【在线问答】</span><br /><a href="#" >[{类型}] {题干，这里会显示问题的标题}<br />点击进入答题>></a>
	</div>
  </div>
  
     

    <!-- end #sidebar1 --></div>
  <div id="mainContent">
  		
          
                        <div id="contentdiv">                            
                     <div id="atTitle"><h1>整理SQL*PLUS命令</h1></div>
					<div id="atSource"> 作者：[网上资料 ] </div>
					
                    <div id="viewcontent">
                   编辑整理SQL*PLUS命令使用大全<br /><a href="../../html/Oracle/l_7_1.htm" title="Oracle" >Oracle</a>的sql*plus是与<a href="../../html/Oracle/l_7_1.htm" title="oracle" >oracle</a>进行交互的客户端工具。在sql*plus中，可以运行sql*plus命令与sql*plus语句。&nbsp;&nbsp; &nbsp;我们通常所说的DML、DDL、DCL语句都是sql*plus语句，它们执行完后，都可以保存在一个被称为sql buffer的内存区域中，并且只能保存一条最近执行的sql语句，我们可以对保存在sql buffer中的sql 语句进行修改，然后再次执行，sql*plus一般都与数据库打交道。&nbsp;&nbsp; &nbsp;除了sql*plus语句，在sql*plus中执行的其它语句我们称之为sql*plus命令。它们执行完后，不保存在sql buffer的内存区域中，它们一般用来对输出的结果进行格式化显示，以便于制作报表。&nbsp;&nbsp; &nbsp;下面就介绍一下一些常用的sql*plus命令：&nbsp;&nbsp;&nbsp;1. 执行一个SQL脚本文件&nbsp;SQL&gt;start file_name&nbsp;SQL&gt;@ file_name&nbsp;我们可以将多条sql语句保存在一个文本文件中，这样当要执行这个文件中的所有的sql语句时，用上面的任一命令即可，这类似于dos中的批处理。&nbsp;@与@@的区别是什么？@等于start命令，用来运行一个sql脚本文件。@命令调用当前目录下的，或指定全路径，或可以通过SQLPATH环境变量搜寻到的脚本文件。该命令使用是一般要指定要执行的文件的全路径，否则从缺省路径(可用SQLPATH变量指定)下读取指定的文件。@@用在sql脚本文件中，用来说明用@@执行的sql脚本文件与@@所在的文件在同一目录下，而不用指定要执行sql脚本文件的全路径，也不是从SQLPATH环境变量指定的路径中寻找sql脚本文件，该命令一般用在脚本文件中。如：在c:\temp目录下有文件start.sql和nest_start.sql，start.sql脚本文件的内容为：@@nest_start.sql&nbsp; &nbsp;&nbsp;&nbsp;- - 相当于@ c:\temp\nest_start.sql则我们在sql*plus中，这样执行：SQL&gt; @ c:\temp\start.sql&nbsp;2. 对当前的输入进行编辑&nbsp;SQL&gt;edit&nbsp;&nbsp;&nbsp;3. 重新运行上一次运行的sql语句&nbsp;SQL&gt;/&nbsp;&nbsp;&nbsp;4. 将显示的内容输出到指定文件&nbsp;SQL&gt; SPOOL file_name&nbsp;&nbsp; &nbsp;在屏幕上的所有内容都包含在该文件中，包括你输入的sql语句。&nbsp;&nbsp;&nbsp;5. 关闭spool输出&nbsp;SQL&gt; SPOOL OFF&nbsp;&nbsp; &nbsp;只有关闭spool输出，才会在输出文件中看到输出的内容。&nbsp;&nbsp;&nbsp;6．显示一个表的结构&nbsp;SQL&gt; desc table_name&nbsp;&nbsp;&nbsp;7. COL命令：&nbsp;主要格式化列的显示形式。&nbsp;该命令有许多选项，具体如下：&nbsp;COL[UMN] [{ column|expr} [ option ...]]&nbsp;Option选项可以是如下的子句:&nbsp;ALI[AS] alias&nbsp;CLE[AR]&nbsp;FOLD_A[FTER]&nbsp;FOLD_B[EFORE]&nbsp;FOR[MAT] format&nbsp;HEA[DING] text&nbsp;JUS[TIFY] {L[EFT]|C[ENTER]|C[ENTRE]|R[IGHT]}&nbsp;LIKE { expr|alias}&nbsp;NEWL[INE]&nbsp;NEW_V[ALUE] variable&nbsp;NOPRI[NT]|PRI[NT]&nbsp;NUL[L] text&nbsp;OLD_V[ALUE] variable&nbsp;ON|OFF&nbsp;WRA[PPED]|WOR[D_WRAPPED]|TRU[NCATED]&nbsp;&nbsp;&nbsp;1). 改变缺省的列标题&nbsp;COLUMN column_name HEADING column_heading&nbsp;For example:&nbsp;Sql&gt;select&nbsp;* from dept;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;DEPTNO DNAME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;LOC&nbsp;---------- ---------------------------- ---------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;10 ACCOUNTING&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; NEW YORK&nbsp;sql&gt;col&nbsp;&nbsp;LOC heading location&nbsp;sql&gt;select * from dept;&nbsp;&nbsp; &nbsp; DEPTNO DNAME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;location&nbsp;--------- ---------------------------- -----------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;10 ACCOUNTING&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; NEW YORK&nbsp;&nbsp;&nbsp;2). 将列名ENAME改为新列名EMPLOYEE NAME并将新列名放在两行上：&nbsp;Sql&gt;select * from emp&nbsp;Department&nbsp;&nbsp;name&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Salary&nbsp;---------- ---------- ----------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;10 aaa&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 11&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SQL&gt; COLUMN ENAME HEADING ’Employee|Name’&nbsp;Sql&gt;select * from emp&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;Employee&nbsp;Department&nbsp;&nbsp;name&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Salary&nbsp;---------- ---------- ----------&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;10 aaa&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 11&nbsp;note: the col heading turn into two lines from one line.&nbsp;&nbsp;&nbsp;3). 改变列的显示长度：&nbsp;FOR[MAT] format&nbsp;Sql&gt;select empno,ename,job from emp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;EMPNO ENAME&nbsp; &nbsp;&nbsp; &nbsp;JOB&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;---------- ----------&nbsp; &nbsp;&nbsp;&nbsp;---------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7369 SMITH&nbsp; &nbsp;&nbsp; &nbsp;CLERK&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7499 ALLEN&nbsp; &nbsp;&nbsp; &nbsp;SALESMAN&nbsp; &nbsp;7521 WARD&nbsp; &nbsp;&nbsp; &nbsp; SALESMAN&nbsp; &nbsp;Sql&gt; col ename format a40&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;EMPNO ENAME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;JOB&nbsp;----------&nbsp; &nbsp;----------------------------------------&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;---------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7369 SMITH&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;CLERK&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7499 ALLEN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SALESMAN&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7521 WARD&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SALESMAN&nbsp;&nbsp;&nbsp;4). 设置列标题的对齐方式&nbsp;JUS[TIFY] {L[EFT]|C[ENTER]|C[ENTRE]|R[IGHT]}&nbsp;SQL&gt; col ename justify center&nbsp;SQL&gt; /&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;EMPNO&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ENAME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; JOB&nbsp;----------&nbsp; &nbsp;----------------------------------------&nbsp; &nbsp;&nbsp; &nbsp; ---------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7369 SMITH&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;CLERK&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7499 ALLEN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SALESMAN&nbsp;7521 WARD&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; SALESMAN&nbsp;对于NUMBER型的列，列标题缺省在右边，其它类型的列标题缺省在左边&nbsp;&nbsp;&nbsp;5). 不让一个列显示在屏幕上&nbsp;NOPRI[NT]|PRI[NT]&nbsp;SQL&gt; col job noprint&nbsp;SQL&gt; /&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;EMPNO&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;ENAME&nbsp;----------&nbsp; &nbsp;&nbsp;&nbsp;----------------------------------------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7369 SMITH&nbsp;&nbsp; &nbsp;&nbsp; &nbsp; 7499 ALLEN&nbsp;7521 WARD&nbsp;&nbsp;&nbsp;6). 格式化NUMBER类型列的显示：&nbsp;SQL&gt; COLUMN SAL FORMAT $99,990&nbsp;SQL&gt; /&nbsp;Employee&nbsp;Department Name&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;Salary&nbsp; &nbsp; Commission&nbsp;---------- ---------- --------- ----------&nbsp;30&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; ALLEN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;$1,600&nbsp; &nbsp; 300&nbsp;&nbsp;&nbsp;7). 显示列值时，如果列值为NULL值，用text值代替NULL值&nbsp;COMM NUL[L] text&nbsp;SQL&gt;COL COMM NUL[L] text&nbsp;&nbsp;&nbsp;8). 设置一个列的回绕方式&nbsp;WRA[PPED]|WOR[D_WRAPPED]|TRU[NCATED]&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;COL1&nbsp;--------------------&nbsp;HOW ARE YOU?&nbsp;&nbsp;&nbsp;SQL&gt;COL COL1 FORMAT A5&nbsp;SQL&gt;COL COL1 WRAPPED&nbsp;COL1&nbsp;-----&nbsp;HOW A&nbsp;RE YO&nbsp;U?&nbsp;&nbsp;&nbsp;SQL&gt; COL COL1 WORD_WRAPPED&nbsp;COL1&nbsp;-----&nbsp;HOW&nbsp;ARE&nbsp;YOU?&nbsp;&nbsp;&nbsp;SQL&gt; COL COL1 WORD_WRAPPED&nbsp;COL1&nbsp;-----&nbsp;HOW A&nbsp;&nbsp;&nbsp;9). 显示列的当前的显示属性值&nbsp;SQL&gt; COLUMN column_name&nbsp;&nbsp;&nbsp;10). 将所有列的显示属性设为缺省值&nbsp;SQL&gt; CLEAR COLUMNS&nbsp;&nbsp;&nbsp;8. 屏蔽掉一个列中显示的相同的值&nbsp;BREAK ON break_column&nbsp;SQL&gt; BREAK ON DEPTNO&nbsp;SQL&gt; SELECT DEPTNO, ENAME, SAL&nbsp;FROM EMP&nbsp;&nbsp;&nbsp;WHERE SAL &amp;lt; 2500&nbsp;&nbsp;&nbsp;ORDER BY DEPTNO;&nbsp;DEPTNO&nbsp; &nbsp;&nbsp; &nbsp;ENAME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SAL&nbsp;---------- ----------- ---------&nbsp;10&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;CLARK&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;2450&nbsp;MILLER&nbsp; &nbsp;&nbsp; &nbsp;1300&nbsp;20&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;SMITH&nbsp; &nbsp;&nbsp; &nbsp; 800&nbsp;ADAMS&nbsp; &nbsp;&nbsp; &nbsp; 1100&nbsp;&nbsp;&nbsp;9. 在上面屏蔽掉一个列中显示的相同的值的显示中，每当列值变化时在值变化之前插入n个空行。BREAK ON break_column SKIP&nbsp;n&nbsp;&nbsp;&nbsp;SQL&gt; BREAK ON DEPTNO SKIP 1&nbsp;SQL&gt; /&nbsp;DEPTNO ENAME SAL&nbsp;---------- ----------- ---------&nbsp;10 CLARK 2450&nbsp;MILLER 1300&nbsp;&nbsp;&nbsp;20 SMITH 800&nbsp;ADAMS 1100&nbsp;&nbsp;&nbsp;10. 显示对BREAK的设置&nbsp;SQL&gt; BREAK&nbsp;&nbsp;&nbsp;11. 删除6、7的设置&nbsp;SQL&gt; CLEAR BREAKS&nbsp;&nbsp;&nbsp;12. Set 命令：&nbsp;该命令包含许多子命令：&nbsp;SET system_variable value&nbsp;system_variable value 可以是如下的子句之一：&nbsp;APPI[NFO]{ON|OFF|text}&nbsp;ARRAY[SIZE] {15|n}&nbsp;AUTO[COMMIT]{ON|OFF|IMM[EDIATE]|n}&nbsp;AUTOP[RINT] {ON|OFF}&nbsp;AUTORECOVERY [ON|OFF]&nbsp;AUTOT[RACE] {ON|OFF|TRACE[ONLY]} [EXP[LAIN]] [STAT[ISTICS]]&nbsp;BLO[CKTERMINATOR] {.|c}&nbsp;CMDS[EP] {;|c|ON|OFF}&nbsp;COLSEP {_|text}&nbsp;COM[PATIBILITY]{V7|V8|NATIVE}&nbsp;CON[CAT] {.|c|ON|OFF}&nbsp;COPYC[OMMIT] {0|n}&nbsp;COPYTYPECHECK {ON|OFF}&nbsp;DEF[INE] {&amp;|c|ON|OFF}&nbsp;DESCRIBE [DEPTH {1|n|ALL}][LINENUM {ON|OFF}][INDENT {ON|OFF}]&nbsp;ECHO {ON|OFF}&nbsp;EDITF[ILE] file_name[.ext]&nbsp;EMB[EDDED] {ON|OFF}&nbsp;ESC[APE] {\|c|ON|OFF}&nbsp;FEED[BACK] {6|n|ON|OFF}&nbsp;FLAGGER {OFF|ENTRY |INTERMED[IATE]|FULL}&nbsp;FLU[SH] {ON|OFF}&nbsp;HEA[DING] {ON|OFF}&nbsp;HEADS[EP] {||c|ON|OFF}&nbsp;INSTANCE [instance_path|LOCAL]&nbsp;LIN[ESIZE] {80|n}&nbsp;LOBOF[FSET] {n|1}&nbsp;LOGSOURCE [pathname]&nbsp;LONG {80|n}&nbsp;LONGC[HUNKSIZE] {80|n}&nbsp;MARK[UP]&nbsp;HTML&nbsp;[ON|OFF] [HEAD text] [BODY text] [ENTMAP {ON|OFF}] [SPOOL&nbsp;{ON|OFF}] [PRE[FORMAT] {ON|OFF}]&nbsp;NEWP[AGE] {1|n|NONE}&nbsp;NULL text&nbsp;NUMF[ORMAT] format&nbsp;NUM[WIDTH] {10|n}&nbsp;PAGES[IZE] {24|n}&nbsp;PAU[SE] {ON|OFF|text}&nbsp;RECSEP {WR[APPED]|EA[CH]|OFF}&nbsp;RECSEPCHAR {_|c}&nbsp;SERVEROUT[PUT] {ON|OFF} [SIZE n] [FOR[MAT] {WRA[PPED]|WOR[D_&nbsp;WRAPPED]|TRU[NCATED]}]&nbsp;SHIFT[INOUT] {VIS[IBLE]|INV[ISIBLE]}&nbsp;SHOW[MODE] {ON|OFF}&nbsp;SQLBL[ANKLINES] {ON|OFF}&nbsp;SQLC[ASE] {MIX[ED]|LO[WER]|UP[PER]}&nbsp;SQLCO[NTINUE] {&gt; |text}&nbsp;SQLN[UMBER] {ON|OFF}&nbsp;SQLPRE[FIX] {#|c}&nbsp;SQLP[ROMPT] {SQL&gt;|text}&nbsp;SQLT[ERMINATOR] {;|c|ON|OFF}&nbsp;SUF[FIX] {SQL|text}&nbsp;TAB {ON|OFF}&nbsp;TERM[OUT] {ON|OFF}&nbsp;TI[ME] {ON|OFF}&nbsp;TIMI[NG] {ON|OFF}&nbsp;TRIM[OUT] {ON|OFF}&nbsp;TRIMS[POOL] {ON|OFF}&nbsp;UND[ERLINE] {-|c|ON|OFF}&nbsp;VER[IFY] {ON|OFF}&nbsp;WRA[P] {ON|OFF}&nbsp;&nbsp;&nbsp;1). 设置当前session是否对修改的数据进行自动提交&nbsp;SQL&gt;SET AUTO[COMMIT] {ON|OFF|IMM[EDIATE]| n}&nbsp;&nbsp;&nbsp;2)．在用start命令执行一个sql脚本时，是否显示脚本中正在执行的SQL语句&nbsp;SQL&gt; SET ECHO {ON|OFF}&nbsp;&nbsp;&nbsp;3).是否显示当前sql语句查询或修改的行数&nbsp;SQL&gt; SET FEED[BACK] {6|n|ON|OFF}&nbsp;&nbsp; &nbsp;默认只有结果大于6行时才显示结果的行数。如果set feedback 1 ，则不管查询到多少行都返回。当为off 时，一律不显示查询的行数&nbsp;&nbsp;&nbsp;4).是否显示列标题&nbsp;SQL&gt; SET HEA[DING] {ON|OFF}&nbsp;当set heading off 时，在每页的上面不显示列标题，而是以空白行代替&nbsp;&nbsp;&nbsp;5).设置一行可以容纳的字符数&nbsp;SQL&gt; SET LIN[ESIZE] {80|n}&nbsp;&nbsp; &nbsp;如果一行的输出内容大于设置的一行可容纳的字符数，则折行显示。&nbsp;&nbsp;&nbsp;6).设置页与页之间的分隔&nbsp;SQL&gt; SET NEWP[AGE] {1|n|NONE}&nbsp;当set newpage 0 时，会在每页的开头有一个小的黑方框。&nbsp;当set newpage n 时，会在页和页之间隔着n个空行。&nbsp;当set newpage none 时，会在页和页之间没有任何间隔。&nbsp;&nbsp;&nbsp;7).显示时，用text值代替NULL值&nbsp;SQL&gt; SET NULL text&nbsp;&nbsp;&nbsp;8).设置一页有多少行数&nbsp;SQL&gt; SET PAGES[IZE] {24|n}&nbsp;如果设为0，则所有的输出内容为一页并且不显示列标题&nbsp;&nbsp;&nbsp;9).是否显示用DBMS_OUTPUT.PUT_LINE包进行输出的信息。&nbsp;SQL&gt; SET&nbsp;SERVEROUT[PUT] {ON|OFF}&nbsp;&nbsp;在编写存储过程时，我们有时会用dbms_output.put_line将必要的信息输出，以便对存储过程进行调试，只有将serveroutput变量设为on后，信息才能显示在屏幕上。&nbsp;&nbsp;&nbsp;10).当SQL语句的长度大于LINESIZE时，是否在显示时截取SQL语句。&nbsp;SQL&gt; SET WRA[P] {ON|OFF}&nbsp;&nbsp; &nbsp;当输出的行的长度大于设置的行的长度时（用set linesize n命令设置），当set wrap on时，输出行的多于的字符会另起一行显示，否则，会将输出行的多于字符切除，不予显示。&nbsp;&nbsp;&nbsp;11).是否在屏幕上显示输出的内容，主要用与SPOOL结合使用。&nbsp;SQL&gt; SET TERM[OUT] {ON|OFF}&nbsp;&nbsp; &nbsp;在用spool命令将一个大表中的内容输出到一个文件中时，将内容输出在屏幕上会耗费大量的时间，设置set termspool off后，则输出的内容只会保存在输出文件中，不会显示在屏幕上，极大的提高了spool的速度。&nbsp;&nbsp;&nbsp;12).将SPOOL输出中每行后面多余的空格去掉&nbsp;SQL&gt; SET TRIMS[OUT] {ON|OFF}&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;13)显示每个sql语句花费的执行时间&nbsp;set TIMING&nbsp;&nbsp;{ON|OFF}&nbsp;14). 遇到空行时不认为语句已经结束，从后续行接着读入。SET SQLBLANKLINES ONSql*plus中, 不允许sql语句中间有空行, 这在从其它地方拷贝脚本到sql*plus中执行时很麻烦. 比如下面的脚本:select deptno, empno, enamefrom empwhere empno = '7788';如果拷贝到sql*plus中执行, 就会出现错误。这个命令可以解决该问题15).设置DBMS_OUTPUT的输出SET SERVEROUTPUT ON BUFFER 20000用dbms_output.put_line('strin_content');可以在存储过程中输出信息，对存储过程进行调试如果想让dbms_output.put_line('&nbsp; &nbsp;&nbsp;&nbsp;abc');的输出显示为：SQL&gt;&nbsp; &nbsp;&nbsp;&nbsp;abc，而不是SQL&gt;abc，则在SET SERVEROUTPUT ON后加format wrapped参数。16). 输出的数据为html格式set markup html在8.1.7版本(也许是816? 不太确定)以后, sql*plus中有一个set markup html的命令, 可以将sql*plus的输出以html格式展现.注意其中的spool on, 当在屏幕上输出的时候, 我们看不出与不加spool on有什么区别, 但是当我们使用spool filename 输出到文件的时候, 会看到spool文件中出现了等tag.14．修改sql buffer中的当前行中，第一个出现的字符串&nbsp;C[HANGE] /old_value/new_value&nbsp;SQL&gt; l&nbsp;&nbsp; &nbsp;1* select * from dept&nbsp;SQL&gt; c/dept/emp&nbsp;&nbsp; &nbsp;1* select * from emp&nbsp;&nbsp;&nbsp;15．编辑sql buffer中的sql语句&nbsp;EDI[T]&nbsp;&nbsp;&nbsp;16．显示sql buffer中的sql语句，list n显示sql buffer中的第n行，并使第n行成为当前行&nbsp;L[IST] [n]&nbsp;&nbsp;&nbsp;17．在sql buffer的当前行下面加一行或多行&nbsp;I[NPUT]&nbsp;&nbsp;&nbsp;18．将指定的文本加到sql buffer的当前行后面&nbsp;A[PPEND]&nbsp;SQL&gt; select deptno,&nbsp;&nbsp; &nbsp;2&nbsp;&nbsp;dname&nbsp;&nbsp; &nbsp;3&nbsp;&nbsp;from dept;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;DEPTNO DNAME&nbsp;---------- --------------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;10 ACCOUNTING&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;20 RESEARCH&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;30 SALES&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;40&nbsp;OPERATIONS&nbsp;&nbsp;&nbsp;SQL&gt; L 2&nbsp;&nbsp; &nbsp;2* dname&nbsp;SQL&gt; a ,loc&nbsp;&nbsp; &nbsp;2* dname,loc&nbsp;SQL&gt; L&nbsp;&nbsp; &nbsp;1&nbsp;&nbsp;select deptno,&nbsp;&nbsp; &nbsp;2&nbsp;&nbsp;dname,loc&nbsp;&nbsp; &nbsp;3* from dept&nbsp;SQL&gt; /&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;DEPTNO DNAME&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; LOC&nbsp;---------- -------------- -------------&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;10 ACCOUNTING&nbsp; &nbsp;&nbsp;&nbsp;NEW YORK&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;20 RESEARCH&nbsp; &nbsp;&nbsp; &nbsp; DALLAS&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;30 SALES&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; CHICAGO&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;40 OPERATIONS&nbsp; &nbsp;&nbsp;&nbsp;BOSTON&nbsp;&nbsp;&nbsp;19．将sql buffer中的sql语句保存到一个文件中&nbsp;SAVE file_name&nbsp;&nbsp;&nbsp;20．将一个文件中的sql语句导入到sql buffer中&nbsp;GET&nbsp;file_name&nbsp;&nbsp;&nbsp;21．再次执行刚才已经执行的sql语句&nbsp;RUN&nbsp;or&nbsp;/&nbsp;&nbsp;&nbsp;22．执行一个存储过程&nbsp;EXECUTE procedure_name&nbsp;&nbsp;&nbsp;23．在sql*plus中连接到指定的数据库&nbsp;CONNECT user_name/passwd@db_alias&nbsp;&nbsp;&nbsp;24．设置每个报表的顶部标题&nbsp;TTITLE&nbsp;&nbsp;&nbsp;25．设置每个报表的尾部标题&nbsp;BTITLE&nbsp;&nbsp;&nbsp;26．写一个注释&nbsp;REMARK [text]&nbsp;&nbsp;&nbsp;27．将指定的信息或一个空行输出到屏幕上&nbsp;PROMPT [text]&nbsp;&nbsp;&nbsp;28．将执行的过程暂停，等待用户响应后继续执行&nbsp;PAUSE [text]&nbsp;&nbsp;&nbsp;Sql&gt;PAUSE Adjust paper and press RETURN to continue.&nbsp;&nbsp;&nbsp;29．将一个数据库中的一些数据拷贝到另外一个数据库（如将一个表的数据拷贝到另一个数据库）&nbsp;COPY {FROM database | TO database | FROM database TO database}&nbsp;{APPEND|CREATE|INSERT|REPLACE} destination_table&nbsp;[(column, column, column, ...)] USING query&nbsp;&nbsp;&nbsp;sql&gt;COPY FROM SCOTT/TIGER@HQ TO JOHN/CHROME@WEST&nbsp;&nbsp;create emp_temp&nbsp;USING SELECT * FROM EMP&nbsp;&nbsp;&nbsp;30．不退出sql*plus，在sql*plus中执行一个操作系统命令：&nbsp;HOST&nbsp;&nbsp;&nbsp;Sql&gt; host hostname&nbsp;该命令在windows下可能被支持。&nbsp;&nbsp;&nbsp;31．在sql*plus中，切换到操作系统命令提示符下，运行操作系统命令后，可以再次切换回sql*plus：&nbsp;!&nbsp;&nbsp;&nbsp;sql&gt;!&nbsp;$hostname&nbsp;$exit&nbsp;sql&gt;&nbsp;&nbsp;&nbsp;该命令在windows下不被支持。&nbsp;&nbsp;&nbsp;32．显示sql*plus命令的帮助&nbsp;HELP&nbsp;如何安装帮助文件：&nbsp;Sql&gt;@ ?\sqlplus\admin\help\hlpbld.sql ?\sqlplus\admin\help\helpus.sql&nbsp;Sql&gt;help index&nbsp;&nbsp;&nbsp;33．显示sql*plus系统变量的值或sql*plus环境变量的值&nbsp;Syntax&nbsp;SHO[W] option&nbsp;where option represents one of the following terms or clauses:&nbsp;system_variable&nbsp;ALL&nbsp;BTI[TLE]&nbsp;ERR[ORS] [{FUNCTION|PROCEDURE|PACKAGE|PACKAGE BODY|&nbsp;TRIGGER|VIEW|TYPE|TYPE BODY} [schema.]name]&nbsp;LNO&nbsp;PARAMETERS [parameter_name]&nbsp;PNO&nbsp;REL[EASE]&nbsp;REPF[OOTER]&nbsp;REPH[EADER]&nbsp;SGA&nbsp;SPOO[L]&nbsp;SQLCODE&nbsp;TTI[TLE]&nbsp;USER&nbsp;&nbsp;&nbsp;1) . 显示当前环境变量的值：&nbsp;Show all&nbsp;&nbsp;&nbsp;2) . 显示当前在创建函数、存储过程、触发器、包等对象的错误信息&nbsp;Show error&nbsp;当创建一个函数、存储过程等出错时，变可以用该命令查看在那个地方出错及相应的出错信息，进行修改后再次进行编译。&nbsp;&nbsp;&nbsp;3) . 显示初始化参数的值：&nbsp;show PARAMETERS [parameter_name]&nbsp;&nbsp;&nbsp;4) . 显示数据库的版本：&nbsp;show REL[EASE]&nbsp;&nbsp;&nbsp;5) . 显示SGA的大小&nbsp;show SGA&nbsp;&nbsp;&nbsp;6). 显示当前的用户名&nbsp;show user34.查询一个用户下的对象SQL&gt;select * from tab;SQL&gt;select * from user_objects;35.查询一个用户下的所有的表SQL&gt;select * from user_tables;36.查询一个用户下的所有的索引SQL&gt;select * from user_indexes;37. 定义一个用户变量方法有两个：a. defineb. COL[UMN] [{column|expr} NEW_V[ALUE] variable [NOPRI[NT]|PRI[NT]]&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; OLD_V[ALUE] variable&nbsp;&nbsp;[NOPRI[NT]|PRI[NT]]下面对每种方式给予解释：a. SyntaxDEF[INE] [variable]|[variable = text]定义一个用户变量并且可以分配给它一个CHAR值。assign the value MANAGER to the variable POS, type:SQL&gt; DEFINE POS = MANAGERassign the CHAR value 20 to the variable DEPTNO, type:SQL&gt; DEFINE DEPTNO = 20list the definition of DEPTNO, enterSQL&gt; DEFINE DEPTNO&nbsp; &nbsp; &nbsp; &nbsp; ―――――――――――――――DEFINE DEPTNO = ”20” (CHAR)定义了用户变量POS后，就可以在sql*plus中用&amp;POS或&amp;&amp;POS来引用该变量的值，sql*plus不会再提示你给变量输入值。b. COL[UMN] [{column|expr} NEW_V[ALUE] variable [NOPRI[NT]|PRI[NT]]NEW_V[ALUE] variable指定一个变量容纳查询出的列值。例:column col_name new_value var_name noprint&nbsp; &nbsp;select col_name from table_name where ……..将下面查询出的col_name列的值赋给var_name变量.一个综合的例子:得到一个列值的两次查询之差(此例为10秒之内共提交了多少事务):column redo_writes new_value commit_countselect sum(stat.value) redo_writesfrom v$sesstat stat, v$statname snwhere stat.statistic# = sn.statistic#and sn.name = 'user commits';-- 等待一会儿(此处为10秒);execute dbms_lock.sleep(10);set veri offselect sum(stat.value) - &amp;commit_count commits_addedfrom v$sesstat stat, v$statname snwhere stat.statistic# = sn.statistic#and sn.name = 'user commits';38. 定义一个绑定变量VAR[IABLE] [variable [NUMBER|CHAR|CHAR (n)|NCHAR|NCHAR (n) |VARCHAR2 (n)|NVARCHAR2 (n)|CLOB|NCLOB|REFCURSOR]]定义一个绑定变量，该变量可以在pl/sql中引用。可以用print命令显示该绑定变量的信息。如：column inst_num&nbsp;&nbsp;heading "Inst Num"&nbsp;&nbsp;new_value inst_num&nbsp;&nbsp;format 99999;column inst_name heading "Instance"&nbsp;&nbsp;new_value inst_name format a12;column db_name&nbsp; &nbsp;heading "DB Name"&nbsp; &nbsp;new_value db_name&nbsp; &nbsp;format a12;column dbid&nbsp; &nbsp;&nbsp; &nbsp;heading "DB Id"&nbsp; &nbsp;&nbsp;&nbsp;new_value dbid&nbsp; &nbsp;&nbsp; &nbsp;format 9999999999 just c;promptprompt Current Instanceprompt ~~~~~~~~~~~~~~~~select d.dbid&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;dbid&nbsp; &nbsp;&nbsp;&nbsp;, d.name&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;db_name&nbsp; &nbsp;&nbsp;&nbsp;, i.instance_number inst_num&nbsp; &nbsp;&nbsp;&nbsp;, i.instance_name&nbsp; &nbsp;inst_name&nbsp;&nbsp;from v$database d,&nbsp; &nbsp;&nbsp; &nbsp; v$instance i;variable dbid&nbsp; &nbsp;&nbsp; &nbsp; number;variable inst_num&nbsp; &nbsp;number;begin&nbsp;&nbsp;:dbid&nbsp; &nbsp;&nbsp; &nbsp;:=&nbsp;&nbsp;&amp;dbid;&nbsp;&nbsp;:inst_num&nbsp;&nbsp;:=&nbsp;&nbsp;&amp;inst_num;end;/说明：在sql*plus中，该绑定变量可以作为一个存储过程的参数，也可以在匿名PL/SQL块中直接引用。为了显示用VARIABLE命令创建的绑定变量的值，可以用print命令注意：绑定变量不同于变量：1．&nbsp; &nbsp; &nbsp; &nbsp; 定义方法不同2．&nbsp; &nbsp; &nbsp; &nbsp; 引用方法不同绑定变量：:variable_name&nbsp; &nbsp; &nbsp; &nbsp; 变量：&amp;variable_name or &amp;&amp;variable_name3.在sql*plus中，可以定义同名的绑定变量与用户变量，但是引用的方法不同。39. &amp;与&amp;&amp;的区别&amp;用来创建一个临时变量，每当遇到这个临时变量时，都会提示你输入一个值。&amp;&amp;用来创建一个持久变量，就像用用define命令或带new_vlaue字句的column命令创建的持久变量一样。当用&amp;&amp;命令引用这个变量时，不会每次遇到该变量就提示用户键入值，而只是在第一次遇到时提示一次。如，将下面三行语句存为一个脚本文件，运行该脚本文件，会提示三次，让输入deptnoval的值：select count(*) from emp where deptno = &amp;deptnoval;select count(*) from emp where deptno = &amp;deptnoval;select count(*) from emp where deptno = &amp;deptnoval;将下面三行语句存为一个脚本文件，运行该脚本文件，则只会提示一次，让输入deptnoval的值：select count(*) from emp where deptno = &amp;&amp;deptnoval;select count(*) from emp where deptno = &amp;&amp;deptnoval;select count(*) from emp where deptno = &amp;&amp;deptnoval;40．在输入sql语句的过程中临时先运行一个sql*plus命令(摘自www.itpub.com)#有没有过这样的经历? 在sql*plus中敲了很长的命令后, 突然发现想不起某个列的名字了, 如果取消当前的命令,待查询后再重敲, 那太痛苦了. 当然你可以另开一个sql*plus窗口进行查询, 但这里提供的方法更简单.比如说, 你想查工资大于4000的员工的信息, 输入了下面的语句:SQL&gt; select deptno, empno, ename2 from emp3 where这时, 你发现你想不起来工资的列名是什么了.这种情况下, 只要在下一行以#开头, 就可以执行一条sql*plus命令, 执行完后, 刚才的语句可以继续输入SQL&gt;&gt; select deptno, empno, ename2 from emp3 where6 #desc empName Null? Type----------------------------------------- -------- --------------EMPNO NOT NULL NUMBER(4)ENAME VARCHAR2(10)JOB VARCHAR2(9)MGR NUMBER(4)HIREDATE DATESAL NUMBER(7,2)COMM NUMBER(7,2)DEPTNO NUMBER(2)6 sal &gt; 4000;DEPTNO EMPNO ENAME---------- ---------- ----------10 7839 KING41. SQLPlus中的快速复制和粘贴技巧(摘自www.cnoug.org)1) 鼠标移至想要复制内容的开始&nbsp;2) 用右手食指按下鼠标左键&nbsp;3) 向想要复制内容的另一角拖动鼠标，与Word中选取内容的方法一样&nbsp;4) 内容选取完毕后（所选内容全部反显），鼠标左键按住不动，用右手中指按鼠标右键&nbsp;5) 这时，所选内容会自动复制到SQL*Plus环境的最后一行<br />
																	|
</div>  
 
                    </div>
                    <hr class="hrdt" />	
<div id="res"></div>
                        
                        </div>

<!-- end #mainContent --></div>
	<!-- 这个用于清除浮动的元素应当紧跟 #mainContent div 之后，以便强制 #container div 包含所有的子浮动 -->
	<br class="clearfloat" />

      
   
	<div id="footer">
  <ul class="green_1">		<li><div id="slogo"></div></li>		<li><div id="bline"></div></li>		<li><div id="binfo">网站名称：数据库DBA学习网站 www.580top.com<br />网络维护：51ak(微信:sohu91) <br /></div></li>	</ul>
   <script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script>
<script>LA.init({id:"K2Iiv8isAYH4TLPh",ck:"K2Iiv8isAYH4TLPh"})</script>
  <!-- end #footer --></div>
  <!-- end #footer --></div>
<!-- end #container --></div>
</body>
</html>
